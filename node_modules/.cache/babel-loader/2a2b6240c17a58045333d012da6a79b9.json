{"ast":null,"code":"import { useId as e } from \"@radix-ui/react-id\";\nimport * as o from \"@radix-ui/react-visually-hidden\";\nimport { Slottable as t } from \"@radix-ui/react-slot\";\nimport { Portal as r } from \"@radix-ui/react-portal\";\nimport * as n from \"@radix-ui/react-popper\";\nimport { createPopperScope as i } from \"@radix-ui/react-popper\";\nimport { Primitive as a } from \"@radix-ui/react-primitive\";\nimport { Presence as l } from \"@radix-ui/react-presence\";\nimport { useRect as c } from \"@radix-ui/react-use-rect\";\nimport { usePrevious as s } from \"@radix-ui/react-use-previous\";\nimport { useEscapeKeydown as u } from \"@radix-ui/react-use-escape-keydown\";\nimport { useControllableState as p } from \"@radix-ui/react-use-controllable-state\";\nimport { createContextScope as d } from \"@radix-ui/react-context\";\nimport { useComposedRefs as m } from \"@radix-ui/react-compose-refs\";\nimport { composeEventHandlers as f } from \"@radix-ui/primitive\";\nimport * as T from \"react\";\nimport C from \"@babel/runtime/helpers/esm/extends\";\nconst [w, x] = d(\"Tooltip\", [i]);\nexport { x as createTooltipScope };\nconst g = i(),\n      E = 700,\n      [v, b] = w(\"TooltipProvider\", {\n  isOpenDelayed: !0,\n  delayDuration: E,\n  onOpen: () => {},\n  onClose: () => {}\n});\nexport const TooltipProvider = e => {\n  const {\n    __scopeTooltip: o,\n    delayDuration: t = E,\n    skipDelayDuration: r = 300,\n    children: n\n  } = e,\n        [i, a] = T.useState(!0),\n        l = T.useRef(0);\n  return T.useEffect(() => {\n    const e = l.current;\n    return () => window.clearTimeout(e);\n  }, []), /*#__PURE__*/T.createElement(v, {\n    scope: o,\n    isOpenDelayed: i,\n    delayDuration: t,\n    onOpen: T.useCallback(() => {\n      window.clearTimeout(l.current), a(!1);\n    }, []),\n    onClose: T.useCallback(() => {\n      window.clearTimeout(l.current), l.current = window.setTimeout(() => a(!0), r);\n    }, [r])\n  }, n);\n};\n/*#__PURE__*/\n\nconst [y, _] = w(\"Tooltip\");\nexport const Tooltip = o => {\n  const {\n    __scopeTooltip: t,\n    children: r,\n    open: i,\n    defaultOpen: a = !1,\n    onOpenChange: l,\n    delayDuration: c\n  } = o,\n        s = b(\"Tooltip\", t),\n        u = g(t),\n        [d, m] = T.useState(null),\n        f = e(),\n        C = T.useRef(0),\n        w = null != c ? c : s.delayDuration,\n        x = T.useRef(!1),\n        {\n    onOpen: E,\n    onClose: v\n  } = s,\n        [_ = !1, h] = p({\n    prop: i,\n    defaultProp: a,\n    onChange: e => {\n      e && (document.dispatchEvent(new CustomEvent(\"tooltip.open\")), E()), null == l || l(e);\n    }\n  }),\n        k = T.useMemo(() => _ ? x.current ? \"delayed-open\" : \"instant-open\" : \"closed\", [_]),\n        D = T.useCallback(() => {\n    window.clearTimeout(C.current), x.current = !1, h(!0);\n  }, [h]),\n        O = T.useCallback(() => {\n    window.clearTimeout(C.current), C.current = window.setTimeout(() => {\n      x.current = !0, h(!0);\n    }, w);\n  }, [w, h]);\n  return T.useEffect(() => () => window.clearTimeout(C.current), []), /*#__PURE__*/T.createElement(n.Root, u, /*#__PURE__*/T.createElement(y, {\n    scope: t,\n    contentId: f,\n    open: _,\n    stateAttribute: k,\n    trigger: d,\n    onTriggerChange: m,\n    onTriggerEnter: T.useCallback(() => {\n      s.isOpenDelayed ? O() : D();\n    }, [s.isOpenDelayed, O, D]),\n    onOpen: T.useCallback(D, [D]),\n    onClose: T.useCallback(() => {\n      window.clearTimeout(C.current), h(!1), v();\n    }, [h, v])\n  }, r));\n};\n/*#__PURE__*/\n\nexport const TooltipTrigger = /*#__PURE__*/T.forwardRef((e, o) => {\n  const {\n    __scopeTooltip: t,\n    ...r\n  } = e,\n        i = _(\"TooltipTrigger\", t),\n        l = g(t),\n        c = m(o, i.onTriggerChange),\n        s = T.useRef(!1),\n        u = T.useCallback(() => s.current = !1, []);\n\n  return T.useEffect(() => () => document.removeEventListener(\"mouseup\", u), [u]), /*#__PURE__*/T.createElement(n.Anchor, C({\n    asChild: !0\n  }, l), /*#__PURE__*/T.createElement(a.button, C({\n    \"aria-describedby\": i.open ? i.contentId : void 0,\n    \"data-state\": i.stateAttribute\n  }, r, {\n    ref: c,\n    onMouseEnter: f(e.onMouseEnter, i.onTriggerEnter),\n    onMouseLeave: f(e.onMouseLeave, i.onClose),\n    onMouseDown: f(e.onMouseDown, () => {\n      i.onClose(), s.current = !0, document.addEventListener(\"mouseup\", u, {\n        once: !0\n      });\n    }),\n    onFocus: f(e.onFocus, () => {\n      s.current || i.onOpen();\n    }),\n    onBlur: f(e.onBlur, i.onClose),\n    onClick: f(e.onClick, i.onClose)\n  })));\n});\n/*#__PURE__*/\n\nexport const TooltipContent = /*#__PURE__*/T.forwardRef((e, o) => {\n  const {\n    forceMount: t,\n    ...r\n  } = e,\n        n = _(\"TooltipContent\", e.__scopeTooltip);\n  /*#__PURE__*/\n\n\n  return T.createElement(l, {\n    present: t || n.open\n  }, /*#__PURE__*/T.createElement(h, C({\n    ref: o\n  }, r)));\n});\nconst h = /*#__PURE__*/T.forwardRef((e, i) => {\n  const {\n    __scopeTooltip: a,\n    children: l,\n    \"aria-label\": c,\n    portalled: s = !0,\n    ...p\n  } = e,\n        d = _(\"TooltipContent\", a),\n        m = g(a),\n        f = s ? r : T.Fragment,\n        {\n    onClose: w\n  } = d;\n\n  return u(() => w()), T.useEffect(() => (document.addEventListener(\"tooltip.open\", w), () => document.removeEventListener(\"tooltip.open\", w)), [w]), /*#__PURE__*/T.createElement(f, null, /*#__PURE__*/T.createElement(k, {\n    __scopeTooltip: a\n  }), /*#__PURE__*/T.createElement(n.Content, C({\n    \"data-state\": d.stateAttribute\n  }, m, p, {\n    ref: i,\n    style: { ...p.style,\n      \"--radix-tooltip-content-transform-origin\": \"var(--radix-popper-transform-origin)\"\n    }\n  }), /*#__PURE__*/T.createElement(t, null, l), /*#__PURE__*/T.createElement(o.Root, {\n    id: d.contentId,\n    role: \"tooltip\"\n  }, c || l)));\n});\n/*#__PURE__*/\n\nexport const TooltipArrow = /*#__PURE__*/T.forwardRef((e, o) => {\n  const {\n    __scopeTooltip: t,\n    ...r\n  } = e,\n        i = g(t);\n  /*#__PURE__*/\n\n  return T.createElement(n.Arrow, C({}, i, r, {\n    ref: o\n  }));\n});\n/*#__PURE__*/\n\nfunction k(e) {\n  const {\n    __scopeTooltip: o\n  } = e,\n        t = _(\"CheckTriggerMoved\", o),\n        r = c(t.trigger),\n        n = null == r ? void 0 : r.left,\n        i = s(n),\n        a = null == r ? void 0 : r.top,\n        l = s(a),\n        u = t.onClose;\n\n  return T.useEffect(() => {\n    (void 0 !== i && i !== n || void 0 !== l && l !== a) && u();\n  }, [u, i, l, n, a]), null;\n}\n\nexport const Provider = TooltipProvider;\nexport const Root = Tooltip;\nexport const Trigger = TooltipTrigger;\nexport const Content = TooltipContent;\nexport const Arrow = TooltipArrow;","map":{"version":3,"mappings":"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","names":["createTooltipContext","createTooltipScope","createContextScope","createPopperScope","usePopperScope","DEFAULT_DELAY_DURATION","TooltipProviderContextProvider","useTooltipProviderContext","isOpenDelayed","delayDuration","onOpen","onClose","TooltipProvider","props","__scopeTooltip","skipDelayDuration","children","setIsOpenDelayed","React","useState","skipDelayTimerRef","useRef","useEffect","skipDelayTimer","current","window","clearTimeout","_react","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$TooltipProviderContextProvider","scope","useCallback","setTimeout","TooltipContextProvider","useTooltipContext","Tooltip","open","openProp","defaultOpen","onOpenChange","delayDurationProp","context","popperScope","trigger","setTrigger","contentId","useId","openTimerRef","wasOpenDelayedRef","setOpen","useControllableState","prop","defaultProp","onChange","document","dispatchEvent","CustomEvent","stateAttribute","useMemo","handleOpen","handleDelayedOpen","_radixUiReactPopper","Root","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$TooltipContextProvider","onTriggerChange","onTriggerEnter","TooltipTrigger","forwardRef","forwardedRef","triggerProps","composedTriggerRef","useComposedRefs","isMouseDownRef","handleMouseUp","removeEventListener","Anchor","asChild","_babelRuntimeHelpersEsmExtends","Primitive","button","undefined","ref","onMouseEnter","composeEventHandlers","onMouseLeave","onMouseDown","addEventListener","once","onFocus","onBlur","onClick","TooltipContent","forceMount","contentProps","Presence","present","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$TooltipContentImpl","TooltipContentImpl","ariaLabel","portalled","PortalWrapper","Portal","Fragment","useEscapeKeydown","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$CheckTriggerMoved","Content","style","Slottable","_radixUiReactVisuallyHidden","id","role","TooltipArrow","arrowProps","Arrow","CheckTriggerMoved","triggerRect","useRect","triggerLeft","left","previousTriggerLeft","usePrevious","triggerTop","top","previousTriggerTop","handleClose","Provider","Trigger"],"sources":["/Users/tamurakeito/Desktop/facemesh/node_modules/@radix-ui/react-tooltip/dist/packages/react/tooltip/src/Tooltip.tsx"],"sourcesContent":["import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useEscapeKeydown } from '@radix-ui/react-use-escape-keydown';\nimport { usePrevious } from '@radix-ui/react-use-previous';\nimport { useRect } from '@radix-ui/react-use-rect';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport * as PopperPrimitive from '@radix-ui/react-popper';\nimport { createPopperScope } from '@radix-ui/react-popper';\nimport { Portal } from '@radix-ui/react-portal';\nimport { Slottable } from '@radix-ui/react-slot';\nimport * as VisuallyHiddenPrimitive from '@radix-ui/react-visually-hidden';\nimport { useId } from '@radix-ui/react-id';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\ntype ScopedProps<P = {}> = P & { __scopeTooltip?: Scope };\nconst [createTooltipContext, createTooltipScope] = createContextScope('Tooltip', [\n  createPopperScope,\n]);\nconst usePopperScope = createPopperScope();\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipProvider\n * -----------------------------------------------------------------------------------------------*/\n\nconst PROVIDER_NAME = 'TooltipProvider';\nconst DEFAULT_DELAY_DURATION = 700;\nconst TOOLTIP_OPEN = 'tooltip.open';\n\ntype TooltipProviderContextValue = {\n  isOpenDelayed: boolean;\n  delayDuration: number;\n  onOpen(): void;\n  onClose(): void;\n};\n\nconst [TooltipProviderContextProvider, useTooltipProviderContext] =\n  createTooltipContext<TooltipProviderContextValue>(PROVIDER_NAME, {\n    isOpenDelayed: true,\n    delayDuration: DEFAULT_DELAY_DURATION,\n    onOpen: () => {},\n    onClose: () => {},\n  });\n\ninterface TooltipProviderProps {\n  /**\n   * The duration from when the mouse enters the trigger until the tooltip gets opened.\n   * @defaultValue 700\n   */\n  delayDuration?: number;\n  /**\n   * How much time a user has to enter another trigger without incurring a delay again.\n   * @defaultValue 300\n   */\n  skipDelayDuration?: number;\n  children: React.ReactNode;\n}\n\nconst TooltipProvider: React.FC<TooltipProviderProps> = (\n  props: ScopedProps<TooltipProviderProps>\n) => {\n  const {\n    __scopeTooltip,\n    delayDuration = DEFAULT_DELAY_DURATION,\n    skipDelayDuration = 300,\n    children,\n  } = props;\n  const [isOpenDelayed, setIsOpenDelayed] = React.useState(true);\n  const skipDelayTimerRef = React.useRef(0);\n\n  React.useEffect(() => {\n    const skipDelayTimer = skipDelayTimerRef.current;\n    return () => window.clearTimeout(skipDelayTimer);\n  }, []);\n\n  return (\n    <TooltipProviderContextProvider\n      scope={__scopeTooltip}\n      isOpenDelayed={isOpenDelayed}\n      delayDuration={delayDuration}\n      onOpen={React.useCallback(() => {\n        window.clearTimeout(skipDelayTimerRef.current);\n        setIsOpenDelayed(false);\n      }, [])}\n      onClose={React.useCallback(() => {\n        window.clearTimeout(skipDelayTimerRef.current);\n        skipDelayTimerRef.current = window.setTimeout(\n          () => setIsOpenDelayed(true),\n          skipDelayDuration\n        );\n      }, [skipDelayDuration])}\n    >\n      {children}\n    </TooltipProviderContextProvider>\n  );\n};\n\nTooltipProvider.displayName = PROVIDER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * Tooltip\n * -----------------------------------------------------------------------------------------------*/\n\nconst TOOLTIP_NAME = 'Tooltip';\n\ntype TooltipContextValue = {\n  contentId: string;\n  open: boolean;\n  stateAttribute: 'closed' | 'delayed-open' | 'instant-open';\n  trigger: TooltipTriggerElement | null;\n  onTriggerChange(trigger: TooltipTriggerElement | null): void;\n  onTriggerEnter(): void;\n  onOpen(): void;\n  onClose(): void;\n};\n\nconst [TooltipContextProvider, useTooltipContext] =\n  createTooltipContext<TooltipContextValue>(TOOLTIP_NAME);\n\ninterface TooltipProps {\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?: (open: boolean) => void;\n\n  /**\n   * The duration from when the mouse enters the trigger until the tooltip gets opened. This will\n   * override the prop with the same name passed to Provider.\n   * @defaultValue 700\n   */\n  delayDuration?: number;\n  children?: React.ReactNode;\n}\n\nconst Tooltip: React.FC<TooltipProps> = (props: ScopedProps<TooltipProps>) => {\n  const {\n    __scopeTooltip,\n    children,\n    open: openProp,\n    defaultOpen = false,\n    onOpenChange,\n    delayDuration: delayDurationProp,\n  } = props;\n  const context = useTooltipProviderContext(TOOLTIP_NAME, __scopeTooltip);\n  const popperScope = usePopperScope(__scopeTooltip);\n  const [trigger, setTrigger] = React.useState<HTMLButtonElement | null>(null);\n  const contentId = useId();\n  const openTimerRef = React.useRef(0);\n  const delayDuration = delayDurationProp ?? context.delayDuration;\n  const wasOpenDelayedRef = React.useRef(false);\n  const { onOpen, onClose } = context;\n  const [open = false, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: (open) => {\n      if (open) {\n        // we dispatch here so `TooltipProvider` isn't required to\n        // ensure other tooltips are aware of this one opening.\n        document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));\n        onOpen();\n      }\n      onOpenChange?.(open);\n    },\n  });\n  const stateAttribute = React.useMemo(() => {\n    return open ? (wasOpenDelayedRef.current ? 'delayed-open' : 'instant-open') : 'closed';\n  }, [open]);\n\n  const handleOpen = React.useCallback(() => {\n    window.clearTimeout(openTimerRef.current);\n    wasOpenDelayedRef.current = false;\n    setOpen(true);\n  }, [setOpen]);\n\n  const handleDelayedOpen = React.useCallback(() => {\n    window.clearTimeout(openTimerRef.current);\n    openTimerRef.current = window.setTimeout(() => {\n      wasOpenDelayedRef.current = true;\n      setOpen(true);\n    }, delayDuration);\n  }, [delayDuration, setOpen]);\n\n  React.useEffect(() => {\n    return () => window.clearTimeout(openTimerRef.current);\n  }, []);\n\n  return (\n    <PopperPrimitive.Root {...popperScope}>\n      <TooltipContextProvider\n        scope={__scopeTooltip}\n        contentId={contentId}\n        open={open}\n        stateAttribute={stateAttribute}\n        trigger={trigger}\n        onTriggerChange={setTrigger}\n        onTriggerEnter={React.useCallback(() => {\n          if (context.isOpenDelayed) handleDelayedOpen();\n          else handleOpen();\n        }, [context.isOpenDelayed, handleDelayedOpen, handleOpen])}\n        onOpen={React.useCallback(handleOpen, [handleOpen])}\n        onClose={React.useCallback(() => {\n          window.clearTimeout(openTimerRef.current);\n          setOpen(false);\n          onClose();\n        }, [setOpen, onClose])}\n      >\n        {children}\n      </TooltipContextProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nTooltip.displayName = TOOLTIP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'TooltipTrigger';\n\ntype TooltipTriggerElement = React.ElementRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = Radix.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface TooltipTriggerProps extends PrimitiveButtonProps {}\n\nconst TooltipTrigger = React.forwardRef<TooltipTriggerElement, TooltipTriggerProps>(\n  (props: ScopedProps<TooltipTriggerProps>, forwardedRef) => {\n    const { __scopeTooltip, ...triggerProps } = props;\n    const context = useTooltipContext(TRIGGER_NAME, __scopeTooltip);\n    const popperScope = usePopperScope(__scopeTooltip);\n    const composedTriggerRef = useComposedRefs(forwardedRef, context.onTriggerChange);\n    const isMouseDownRef = React.useRef(false);\n    const handleMouseUp = React.useCallback(() => (isMouseDownRef.current = false), []);\n\n    React.useEffect(() => {\n      return () => document.removeEventListener('mouseup', handleMouseUp);\n    }, [handleMouseUp]);\n\n    return (\n      <PopperPrimitive.Anchor asChild {...popperScope}>\n        <Primitive.button\n          // We purposefully avoid adding `type=button` here because tooltip triggers are also\n          // commonly anchors and the anchor `type` attribute signifies MIME type.\n          aria-describedby={context.open ? context.contentId : undefined}\n          data-state={context.stateAttribute}\n          {...triggerProps}\n          ref={composedTriggerRef}\n          onMouseEnter={composeEventHandlers(props.onMouseEnter, context.onTriggerEnter)}\n          onMouseLeave={composeEventHandlers(props.onMouseLeave, context.onClose)}\n          onMouseDown={composeEventHandlers(props.onMouseDown, () => {\n            context.onClose();\n            isMouseDownRef.current = true;\n            document.addEventListener('mouseup', handleMouseUp, { once: true });\n          })}\n          onFocus={composeEventHandlers(props.onFocus, () => {\n            if (!isMouseDownRef.current) context.onOpen();\n          })}\n          onBlur={composeEventHandlers(props.onBlur, context.onClose)}\n          // Handle anything that the browser considers a click for the element type if\n          // not using pointer e.g. Space keyup and Enter keydown\n          onClick={composeEventHandlers(props.onClick, context.onClose)}\n        />\n      </PopperPrimitive.Anchor>\n    );\n  }\n);\n\nTooltipTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'TooltipContent';\n\ntype TooltipContentElement = TooltipContentImplElement;\ninterface TooltipContentProps extends TooltipContentImplProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst TooltipContent = React.forwardRef<TooltipContentElement, TooltipContentProps>(\n  (props: ScopedProps<TooltipContentProps>, forwardedRef) => {\n    const { forceMount, ...contentProps } = props;\n    const context = useTooltipContext(CONTENT_NAME, props.__scopeTooltip);\n    return (\n      <Presence present={forceMount || context.open}>\n        <TooltipContentImpl ref={forwardedRef} {...contentProps} />\n      </Presence>\n    );\n  }\n);\n\ntype TooltipContentImplElement = React.ElementRef<typeof PopperPrimitive.Content>;\ntype PopperContentProps = Radix.ComponentPropsWithoutRef<typeof PopperPrimitive.Content>;\ninterface TooltipContentImplProps extends PopperContentProps {\n  /**\n   * A more descriptive label for accessibility purpose\n   */\n  'aria-label'?: string;\n\n  /**\n   * Whether the Tooltip should render in a Portal\n   * (default: `true`)\n   */\n  portalled?: boolean;\n}\n\nconst TooltipContentImpl = React.forwardRef<TooltipContentImplElement, TooltipContentImplProps>(\n  (props: ScopedProps<TooltipContentImplProps>, forwardedRef) => {\n    const {\n      __scopeTooltip,\n      children,\n      'aria-label': ariaLabel,\n      portalled = true,\n      ...contentProps\n    } = props;\n    const context = useTooltipContext(CONTENT_NAME, __scopeTooltip);\n    const popperScope = usePopperScope(__scopeTooltip);\n    const PortalWrapper = portalled ? Portal : React.Fragment;\n    const { onClose } = context;\n\n    useEscapeKeydown(() => onClose());\n\n    React.useEffect(() => {\n      // Close this tooltip if another one opens\n      document.addEventListener(TOOLTIP_OPEN, onClose);\n      return () => document.removeEventListener(TOOLTIP_OPEN, onClose);\n    }, [onClose]);\n\n    return (\n      <PortalWrapper>\n        <CheckTriggerMoved __scopeTooltip={__scopeTooltip} />\n        <PopperPrimitive.Content\n          data-state={context.stateAttribute}\n          {...popperScope}\n          {...contentProps}\n          ref={forwardedRef}\n          style={{\n            ...contentProps.style,\n            // re-namespace exposed content custom property\n            ['--radix-tooltip-content-transform-origin' as any]:\n              'var(--radix-popper-transform-origin)',\n          }}\n        >\n          <Slottable>{children}</Slottable>\n          <VisuallyHiddenPrimitive.Root id={context.contentId} role=\"tooltip\">\n            {ariaLabel || children}\n          </VisuallyHiddenPrimitive.Root>\n        </PopperPrimitive.Content>\n      </PortalWrapper>\n    );\n  }\n);\n\nTooltipContent.displayName = CONTENT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipArrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_NAME = 'TooltipArrow';\n\ntype TooltipArrowElement = React.ElementRef<typeof PopperPrimitive.Arrow>;\ntype PopperArrowProps = Radix.ComponentPropsWithoutRef<typeof PopperPrimitive.Arrow>;\ninterface TooltipArrowProps extends PopperArrowProps {}\n\nconst TooltipArrow = React.forwardRef<TooltipArrowElement, TooltipArrowProps>(\n  (props: ScopedProps<TooltipArrowProps>, forwardedRef) => {\n    const { __scopeTooltip, ...arrowProps } = props;\n    const popperScope = usePopperScope(__scopeTooltip);\n    return <PopperPrimitive.Arrow {...popperScope} {...arrowProps} ref={forwardedRef} />;\n  }\n);\n\nTooltipArrow.displayName = ARROW_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction CheckTriggerMoved(props: ScopedProps<{}>) {\n  const { __scopeTooltip } = props;\n  const context = useTooltipContext('CheckTriggerMoved', __scopeTooltip);\n\n  const triggerRect = useRect(context.trigger);\n  const triggerLeft = triggerRect?.left;\n  const previousTriggerLeft = usePrevious(triggerLeft);\n  const triggerTop = triggerRect?.top;\n  const previousTriggerTop = usePrevious(triggerTop);\n  const handleClose = context.onClose;\n\n  React.useEffect(() => {\n    // checking if the user has scrolledâ€¦\n    const hasTriggerMoved =\n      (previousTriggerLeft !== undefined && previousTriggerLeft !== triggerLeft) ||\n      (previousTriggerTop !== undefined && previousTriggerTop !== triggerTop);\n\n    if (hasTriggerMoved) {\n      handleClose();\n    }\n  }, [handleClose, previousTriggerLeft, previousTriggerTop, triggerLeft, triggerTop]);\n\n  return null;\n}\n\nconst Provider = TooltipProvider;\nconst Root = Tooltip;\nconst Trigger = TooltipTrigger;\nconst Content = TooltipContent;\nconst Arrow = TooltipArrow;\n\nexport {\n  createTooltipScope,\n  //\n  TooltipProvider,\n  Tooltip,\n  TooltipTrigger,\n  TooltipContent,\n  TooltipArrow,\n  //\n  Provider,\n  Root,\n  Trigger,\n  Content,\n  Arrow,\n};\nexport type { TooltipProps, TooltipTriggerProps, TooltipContentProps, TooltipArrowProps };\n"]},"metadata":{},"sourceType":"module"}